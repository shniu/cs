# 并发编程

## 等待通知机制

多线程的真正价值在于多个线程相互配合完成一件复杂的事情，或者相互配合完成一件计算繁重的任务；可见，相互配合是重点，配合就是分工任务、同步数据和互斥访问共享资源。比如当线程A完成了一件工作后，需要让线程B执行，线程B完成一件工作后，需要让线程C执行，能想到的一种方式是循环检测，一直检测到线程需要的资源都齐备了就进入临界区。但是循环检测的缺点是要空耗CPU，浪费资源，尤其是在共享资源冲突较大时。而等待通知机制就是一种非常好的解决方案。

等待通知机制是 Java 内置的一个功能，需要配合 synchronized/wait\(\)/notify\(\)/notifyAll\(\) 一起使用。基本思想是：

1. 在 synchronized 的同步块中，因为只有多线程访问共享变量才需要等待通知机制
2. 某个线程调用 wait\(\) 进入等待状态，并且线程释放锁
3. 某个线程在执行到某处调用 notify\(\) or notifyAll\(\), 通知等待队列的线程进入同步队列，线程状态变为 BLOCKED，等该线程释放锁之后才可以进入竞争锁的环节
4. 调用 wait\(\) 后再次获得锁，是从 wait\(\) 代码后面开始执行

### 经典范式

等待通知机制的代码实现有固定的套路：

```java
// wait 的代码范式
synchronized (对象lock) {
    while (条件不满足) {
        对象lock.wait();
    }
    其他处理逻辑
}

// notify 的代码范式
syncronized (对象lock) {
    改变条件
    对象lock.notifyAll();
}
```

### Guarded Suspension 模式

todo

