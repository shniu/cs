# Redis 基础

### Redis 数据结构

Redis 接收到一个键值对操作后，能以微秒级别的速度找到数据，并快速完成操作。Redis 能有这么突出的表现：一方面，这是因为它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快（内存访问 100 ns 级别）。另一方面，这要归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。

Redis 支持的基础数据类型：String, List, Set, Sorted Set, Hash；这些数据类型中用到的基本数据结构有：简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。我们所说的数据类型是 Redis 中 Value 的类型，Redis 是由键值对构建的内存数据库，键都是字符串，值却有不同的类型表示。

#### Redis 数据库的键值如何组织？

为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。

![](../../.gitbook/assets/image%20%2857%29.png)

Redis 之所以使用哈希表作为全局的 KV 存储，是利用了哈希表的 O\(1\) 时间复杂度来快速查找到键值对的特性；只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素；这个查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。

但是哈希表有个缺点是：随着键值对的增多，hash bucket 的冲突就会随之增加，这个的解决办法是让 bucket 相同的 entry 用链表连接起来，不可避免的一个问题是这个链表有可能会很长，查找数据的效率就会变慢，在 Redis 中这是不允许的，Redis 要非常快的内存操作。

Redis 引入了 rehash 来解决冲突链过长带来的性能下将问题， rehash 的一般做法是：创建一个更大的 hash 表，把老 hash 表的数据复制到新的 hash 表，然后用新的 hash 表提供服务，但是这种方式在 Redis 中的一个问题是大量的内存复制肯能会阻塞 Redis 的线程，无法服务其他请求，会造成短暂的服务中断，无法快速访问数据。

为了解决这个问题，使用**渐进式 rehash**：Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2，刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash：

1. 给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍
2. 把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中, 但是拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的 entries
3. 释放哈希表 1 的空间

![&#x6E10;&#x8FDB;&#x5F0F; rehash](../../.gitbook/assets/image%20%2861%29.png)

#### Redis 的底层数据结构

* 动态字符串
* 双向链表
* 压缩列表

![ziplist](../../.gitbook/assets/image%20%2860%29.png)

压缩列表是一块连续的内存空间，元素之间紧挨着存储，没有任何冗余空隙。压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。

在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O\(1\)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O\(N\) 了。

```c
struct ziplist<T> {
    int32 zlbytes; // 整个压缩列表占用字节数
    int32 zltail_offset; // 最后一个元素距离压缩列表起始位置的偏移量，
                         // 用于快速定位到最后一个节点, 倒着遍历
    int16 zllength; // 元素个数
    T[] entries; // 元素内容列表，挨个挨个紧凑存储
    int8 zlend; // 标志压缩列表的结束，值恒为 0xFF
}

struct entry {
    int<var> prevlen; // 前一个 entry 的字节长度
    int<var> encoding; // 元素类型编码
    optional byte[] content; // 元素内容
}
```

Redis 为了节约存储空间，对 encoding 字段进行了相当复杂的设计。Redis 通过这个字段的前缀位来识别具体存储的数据形式：

1. `00xxxxxx` 最大长度位 63 的短字符串，后面的 6 个位存储字符串的位数，剩余的字节就是字符串的内容。
2. `01xxxxxx xxxxxxxx` 中等长度的字符串，后面 14 个位来表示字符串的长度，剩余的字节就是字符串的内容。
3. `10000000 aaaaaaaa bbbbbbbb cccccccc dddddddd` 特大字符串，需要使用额外 4 个字节来表示长度。第一个字节前缀是`10`，剩余 6 位没有使用，统一置为零。后面跟着字符串内容。不过这样的大字符串是没有机会使用的，压缩列表通常只是用来存储小数据的。
4. `11000000` 表示 int16，后跟两个字节表示整数。
5. `11010000` 表示 int32，后跟四个字节表示整数。
6. `11100000` 表示 int64，后跟八个字节表示整数。
7. `11110000` 表示 int24，后跟三个字节表示整数。
8. `11111110` 表示 int8，后跟一个字节表示整数。
9. `11111111` 表示 ziplist 的结束，也就是 zlend 的值 0xFF。
10. `1111xxxx` 表示极小整数，xxxx 的范围只能是 \(`0001~1101`\), 也就是`1~13`，因为`0000、1110、1111`都被占用了。读取到的 value 需要将 xxxx 减 1，也就是整数`0~12`就是最终的 value。

`content` 字段在结构体中定义为 optional 类型，表示这个字段是可选的，对于很小的整数而言，它的内容已经内联到 encoding 字段的尾部了。

因为 ziplist 都是紧凑存储，没有冗余空间 \(对比一下 Redis 的字符串结构\)。意味着插入一个新的元素就需要调用 realloc 扩展内存。取决于内存分配器算法和当前的 ziplist 内存大小，realloc 可能会重新分配新的内存空间，并将之前的内容一次性拷贝到新的地址，也可能在原有的地址上进行扩展，这时就不需要进行旧内容的内存拷贝。

如果 ziplist 占据内存太大，重新分配内存和拷贝内存就会有很大的消耗。所以 ziplist 不适合存储大型字符串，存储的元素也不宜过多。

关于 ziplist 更多的源码细节，可参考 [Redis5 设计与源码分析的压缩列表章节](https://weread.qq.com/web/reader/d36322207190b923d368a9ak1ff325f02181ff1de7742fc)

* 哈希表
* 跳表
* 整数数组

#### Redis 集合数据类型、操作及应用

* string
* hash
* list
* set
* sorted set
* HyperLogLog
* bitmap
* GEO
* stream

### Redis 单线程模型和高性能网络模型

通常说，Redis 是单线程，主要是指 Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。可见严格来说，Redis 并不是单线程的。

对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。通常情况下，采用多线程后，如果没有良好的系统设计，实际得到的结果会不尽人意。一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。

并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。

通常来说，单线程的处理能力要比多线程差很多，但是 Redis 却能使用单线程模型达到每秒数十万级别的处理能力，这是为什么呢？一方面，**Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因**。另一方面，**就是 Redis 采用了多路复用机制，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率**。Redis 利用单线程处理核心操作的设计和 LMAX 团队设计 Disruptor 利用单线程处理核心业务逻辑有异曲同工之妙，LMAX 团队利用 Disruptor 实现了一个单线程的 Matching Engine，号称每秒可以处理 600 万订单。

网络 IO 模型

更加深入的学习网络 IO\(网络是一个可以一直学习下去，并不断发现新天地的东西\)，参考：

1. [Reactor 模型论文](http://www.dre.vanderbilt.edu/~schmidt/PDF/reactor-siemens.pdf)
2. [Scalable IO in Java](https://www.cnblogs.com/dafanjoy/p/11217708.html)

### Redis 持久化：AOF 和 RDB



### Redis 复制原理：高可靠的基础







