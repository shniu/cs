---
description: 分析 MySQL 的 InnoDB 存储引擎的索引机制
---

# 索引分析

索引是一种可以提升查询效率的数据结构\(**索引的本质是数据结构**\)。

我们都知道 MySQL 的 InnoDB 存储引擎是使用 B+ Tree 来组织数据的，也就是说 B+ Tree 就是 InnoDB 使用的索引数据结构。

先来搞明白一个事情，为什么查询数据要借助数据库和数据库的索引？通常情况下，我们可以使用操作系统提供的 awk / grep 等来查询数据，顺序遍历文件中的每一行数据，直到找到为止；当数据量比较小时，比如几十兆、几百兆甚至上 GB，这种方式也许还可以应付，但是更多的数据量呢？我们会面临一些问题：

1. 计算机磁盘存在 IO 性能问题，如果把要搜索的数据都加载到内存，是需要时间的
2. 普通的做法需要对数据做全量扫描，全量意味着随着数据量的增长，查询速度会越来越慢
3. 一些常识：a、磁盘读取数据要寻址，要花费几ms级别，当然顺序读写就不需要额外的寻址时间；b、 磁盘的IO，也就是吞吐量，一般的磁盘吞吐在几百M每秒；c、 和内存相比，内存的操作时间是 100纳秒左右，差了 10万倍左右，当然ssd硬盘会更快一点，也会相差几万倍

总结一下，普通的原始做法是把数据顺序存储在文件中，等需要的时候，从头到尾全量遍历直到找到满足要求的数据，**缺点就是需要做全量扫描的IO操作，而且还不支持丰富多样的过滤查询，一个字“慢“，无法应对日益增长的数据量。**而数据库管理系统就是一种解决方案。

> A database needs to do two things: when you give it some data, it should store the data, and when you ask it again later, it should give the data back to you.  
>
>  -- from &lt;&lt; Designing Data-Intensive Applications&gt;&gt;

怎么解决呢？应对海量数据的问题，就是利用**分治思想**，比如说操作系统管理文件系统的方式，磁盘被分成很多的数据块，每个数据块 4 KB 大小（有的是16 K），一个文件就可以被分成很多个 4 K 大小的数据页，实际的数据就被存放在这些数据页中；但是一般磁盘都非常大，比如说一个 1 TB 的磁盘就会有 2 亿个左右的数据页，**维护这么大的数据页就需要借助索引来完成**，建立数据页的索引，用来标识哪个数据存在哪个数据页里，索引就是来加速查找的数据结构，索引也是文件，叫索引文件，**我们可以建立两级索引，第一级索引在内存中，第二级索引在磁盘上，在查询时，首先获取二级索引，然后根据二级索引加载数据页，最后取出数据**。这样即避免了数据的全量IO（因为只加载部分数据），又提高了查询速度。

实质上，InnoDB 的 B+ Tree 索引实现利用了类似的思想：分治 + 多级索引。

### B+ Tree 

为什么选择使用 B+ Tree 来做数据库存储引擎的索引呢？涉及到：局部性原理，文件系统和磁盘的管理，

1. 
### 索引选择与优化



参考资料：

* [MySQL 索引背后的数据结构和算法原理](http://blog.codinglabs.org/articles/theory-of-mysql-index.html)
* [MySQL 索引原理及查询优化](https://tech.meituan.com/2014/06/30/mysql-index.html)

