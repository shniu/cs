---
description: IO 是什么
---

# IO

IO 是输入输出系统，它直接对应于现实中的输入和输出设备，比如非常早期的开关输入和灯泡输出、到后来的鼠标键盘与显示器、以及到现在智能手机的触摸屏和手机屏幕，这些连接了人和计算机，通过输入我们向计算机下达指令，通过输出我们从计算机获得想要的结果，可见这个输入输出系统定义了人与计算机的交互，但是现实世界和计算机世界是非常不一样的，输入要做到让计算机理解，输入要做到让人更方便的阅读。

### IO 基础与设计

计算机在早期的主要目标是运算，甚至是早前计算机的唯一目标；但是到了现在，计算机是我们日常生活中的一部分，我们在日常生活中更多的是和计算机做交互，输入输出设备的种类和功能便得越来越多，越来越复杂。

我们知道在冯-诺伊曼的体系中，把计算机分成了核心的 5 个部分：运算器、控制器、存储器、输入和输出，可见 IO 是非常重要的组成部分；用于输入输出的，可以是简单的拨码开关\(这是非常早期的输入输出设备\)、LED 灯，也可以是复杂的打印机、网卡、显示器、键盘鼠标、硬盘、耳机、麦克风、游戏机控制手柄等；同时，这些设备在传输速率的要求上也比较大，有高速的显示器，有低速的键盘数笔；既有并行接口也有串行接口；既有使用数字电路的也有使用模拟电路的；所以，输入输出设备有如此大的差异，是没有办法直接和 CPU 芯片直接连接的，因为 CPU 本身已经是一个非常复杂的组件了，不能把和各个 IO 设备的差异也让 CPU 在物理设计上去适配，而我们能做的就是在 CPU 的指令上去统一它们，对于 CPU 来讲，IO 设备都是一样的，没有什么区别，这就在设计上引入了一个中转站：IO 接口，这样输入输出就被分为两部分：IO 接口和实现具体功能的外设。

IO 接口的主要能力：

1. 数据缓冲，用于解决高速的 CPU 和低俗的外设之间的差距
2. 提供联络信息，如打印机什么时候能够接收数据
3. 提供格式上的转换，比如模拟信息和数字信号之间的转换，串行信号和并行信号之间的转换，不同电平之间的转换
4. 一个接口可能连接多个设备，比如多个硬盘，那这个接口还要提供设备选择的能力
5. 中断管理
6. 可编程管理

![IO &#x63A5;&#x53E3;](../../.gitbook/assets/image%20%28106%29.png)

 在计算机系统里面，CPU 和 I/O 设备之间的通信，是这么来解决的。

首先，在 I/O 设备这一侧，我们把 I/O 设备拆分成，能和 CPU 通信的接口电路，以及实际的 I/O 设备本身。接口电路里面有对应的状态寄存器、命令寄存器、数据寄存器、数据缓冲区和设备内存等等。接口电路通过总线和 CPU 通信，接收来自 CPU 的指令和数据。而接口电路中的控制电路，再解码接收到的指令，实际去操作对应的硬件设备。

而在 CPU 这一侧，对 CPU 来说，它看到的并不是一个个特定的设备，而是一个个内存地址或者端口地址。CPU 只是向这些地址传输数据或者读取数据。所需要的指令和操作内存地址的指令其实没有什么本质差别。通过软件层面对于传输的命令数据的定义，而不是提供特殊的新的指令，来实际操作对应的 I/O 硬件。

### IO 接口的编址方式

TODO

### IO 控制方式

IO 控制是指主机与外设之间的数据传送控制方式

* 程序控制

其数据传送是在程序的控制下进行的，又分为两种：无条件传送方式和程序查询传送方式。无条件传送方式适合简单外设，如拨码开关和数码管；

程序查询传送方式，需要先编写一段程序，用来查询外设的工作状态，在确定外设已经准备就绪的时候，才进行数据的传送；此外应该 有两根信号线来标明发送方和接收方是否已经准备好。 对于输入设备和输出设备都是如此。 那这对用于交互联络的信号，就叫做握手信号。 在数据传输的每一步，都需要通过握手信号进行确认，然后才可以进行下一步的传输。

数据输出程序查询方式的过程：

1. CPU 执行指令，将控制字写入接口的 控制寄存器，从而设置接口的工作模式
2. CPU 执行指令，将数据写到接口的 输出缓冲寄存器
3. 接口将数据发送到 并行数据输出 信号线上，并将 输出准备好 信号置为有效（也可以又 CPU 写控制字将该信号置为有效）
4. 外设发现 输出准备好 信号有效后，从并行数据输出信号线上接收数据，并将输出回答信号置为有效
5. 接口发现输出回答信号有效后，将状态寄存器中的状态位输出缓冲区置为有效
6. 在这个过程中，CPU 反复执行指令从状态寄存器中读出状态字，直到发现输出缓冲区，然后开始下一个输出过程，继续输出新数据

![&#x6570;&#x636E;&#x8F93;&#x51FA;&#x8FC7;&#x7A0B;&#xFF08;&#x7A0B;&#x5E8F;&#x67E5;&#x8BE2;&#x65B9;&#x5F0F;&#xFF09;](../../.gitbook/assets/image%20%28102%29.png)

数据输入程序查询方式过程：

1. 系统初始化时，CPU 执行指令，将控制字写入接口的控制寄存器，设置接口的工作模式
2. 外设将数据发到并行数据输入信号线上，并将输入准备好信号置为有效
3. 接口发现输入准备好信号有效后，从并行数据输入信号线上接收数据，放入输入缓冲寄存器，并将输入回答置为有效，阻止外设输入新数据
4. 接口将状态寄存器中的状态位输入缓冲满置为有效
5. 在上述过程中，CPU 反复执行指令从状态寄存器中读出状态字，直到发现输入缓冲满，然后执行指令从输入缓冲寄存器中读出数据
6. 接口将输入回答信号置为无效，等待外设输入新数据，当然也会将状态寄存器置为无效等

![&#x6570;&#x636E;&#x8F93;&#x5165;&#x8FC7;&#x7A0B;&#xFF08;&#x7A0B;&#x5E8F;&#x67E5;&#x8BE2;&#x65B9;&#x5F0F;&#xFF09;](../../.gitbook/assets/image%20%28101%29.png)

无条件传送方式，优点是要编写的控制程序非常的简单。 但缺点是只适用于非常简单的外设的操作。 像打印机这种还不算太复杂的设备，就已经不适用了。而程序查询传送方式， 由于有了握手的过程，比无条件传送方式准确和可靠。 但它的缺点是查询外设状态占用了大量的时间。 那这两种方式还有一些共同的特点。 它的优点在于对外设的要求比较低，不需要外设在接口上有很复杂的功能。 而且控制程序的操作流程非常的清晰。 但是缺点在于，要靠CPU进行数据的传送， 如果要传送的数据量很大，除了查询外设状态花的时间 之外，一个一个传送数据也需要花费大量的时间， 占用了CPU非常宝贵的运算资源，从而可能影响这个计算机系统的性能。

![&#x7A0B;&#x5E8F;&#x67E5;&#x8BE2;&#x65B9;&#x5F0F;&#x4F18;&#x7F3A;&#x70B9;](../../.gitbook/assets/image%20%28100%29.png)

* 中断控制

在现在的计算机系统当中， 如果完全依靠CPU进行输入输出，那是有问题的。 比如说我们要通过键盘进行输入，那CPU怎么能保证及时发现键盘的输入呢？ 如果CPU不间断地去查询键盘的输入， 那显然是不合适的，那这样CPU就无法完成其他的任务了。 那如果是间歇地查询呢？先做一段运算的任务，然后查看一下键盘。 那这样也有问题。这个间隔设置为多久合适呢？ 间隔设置的太短，那还是影响CPU执行其他的任务。 间隔设置的太长，又会造成键盘的输入无法得到及时的响应。 所以想要让这个系统正常的工作，我们还得用其他的方法。 这就是我们要介绍的第二种I/O控制方式：中断（也叫外部中断）。

数据输入过程（中断控制方式）：

1. 系统初始化时，CPU 执行指令，将控制字写入接口的控制寄存器，设置接口的工作模式
2. 外设将数据发到并行数据输入信号，并将输入准备好信号置为有效
3. 接口发现输入准备好信号有效后，从并行数据输入信号接收数据，放入输入缓冲寄存器，并将信号置为有效，阻止外设输入新数据
4. 接口通过中断控制逻辑向 CPU 发出中断请求信号，并将状态寄存器中的状态位输入缓冲满置为有效
5. CPU 收到中断请求后，进入中断服务程序，执行指令从状态寄存器中读出状态字，发现输入缓冲满，因此执行指令，从输入缓冲区中读出数据，放入自己的缓冲区中（内存中）
6. 接口将输入回答信号置为无效，等待外设输入新数据；当外设收到输入回答信号无效后，就会继续循环步骤2～6，直到没有数据需要输入

![&#x6570;&#x636E;&#x8F93;&#x5165;&#xFF08;&#x4E2D;&#x65AD;&#x63A7;&#x5236;&#xFF09;](../../.gitbook/assets/image%20%28104%29.png)

数据输出过程（中断控制方式）：

1. CPU 执行指令，将控制字写入接口控制寄存器，从而设置接口的工作模式
2. CPU 执行指令，将数据写入接口的输出缓冲区
3. 接口将数据发到并行数据输出信号，并将输出准备好信号置为有效（也可以由 CPU 写控制字将该信号置为有效）
4. 外设发现输出准备好信号有效后，从并行数据输出信号接收数据，并将输出回答信号置为有效
5. 接口发现输出回答信号有效后，通过中断控制逻辑向 CPU 发出中断请求信号，并将状态寄存器中的状态位输出缓冲空置为有效
6. CPU 收到中断请求后，进入中断服务程序，执行指令从状态寄存器中读出状态字，发现输出缓冲空，因此开始下一个输出过程，继续输出新数据

![&#x6570;&#x636E;&#x8F93;&#x51FA;&#xFF08;&#x4E2D;&#x65AD;&#x63A7;&#x5236;&#xFF09;](../../.gitbook/assets/image%20%28105%29.png)

输入的数据会不断地被 CPU 读走，再写到内存的某个地方。 这样就构成了一大块数据输入的过程。 然后我们再来看看数据输出的过程。 那刚才说要用中断控制方式，是因为不知道输入什么时候发生。 那输出是由CPU控制的，这难道也会不知道什么时候发生吗？ 这当然不是。那为什么要用中断控制方式呢？大多数对外接口的工作频率都是远远低于CPU的工作频率， 而且外设很可能会处在没有准备好的状态。 所以如果不采用中断的方式，CPU在这时就不得不反复地读取状态寄存器， 以确定当前的这个数据已经写到外设了，可以发送新的数据。 那这样也就浪费了CPU的性能。所以我们也可以采用中断控制的方式。 等到外设已经将这个数据取走之后， 再由并行接口电路将中断请求信号置为有效。 同时将状态寄存器当中的“输出缓冲空”状态位置为有效。 那这时CPU可能还在执行别的程序。 在收到中断请求后，又进入了并行接口的中断服务程序。 这和刚才数据输入过程发生的中断使用的是同一个中断向量，进入的也是同一个中断服务程序。

![](../../.gitbook/assets/image%20%2899%29.png)

有了中断控制方式，CPU 就可以和外设在一定程度上并行的工作，提高了工作的效率， 而且这也让外设有了申请服务的主动权。 而不是让程序查询方式那样，CPU什么时候查到你了，才有可能为你提供服务。 现在外设就可以在有需要服务的时候主动向CPU提出请求， 这样在一定程度上，也满足了输入输出处理的实时性要求。 然后我们再来看一看中断控制方式的缺点。 那它最大的缺点就输入输出数据的传送工作任然用CPU来承担。 这样就占用了宝贵的CPU运算资源，而且在存储器和外设之间进行数据的传送， 这种方式仍然需要将数据先放到CPU当中的通用寄存器， 这样通过CPU中转一次的传输过程就会显得很冗长，也影响了输入输出的性能。 当然程序查询方式同样也有这些缺点。 中断控制方式是节省了其中不断查询状态位的那些工作。 但是中断的机制也引入了一些新的开销。比如要进入和退出中断服务程序， 就需要执行额外的一些指令，这些指令和数据传送本身是没有关系的。 而且在现在复杂的操作系统当中，这样额外指令的数目可能还是非常多的。

中断方式就比程序查询方式要好呢？ 倒也未必。中断方式确实提高了整个系统运行的效率。 但是对于一些特别重要的事情，查询方式反而能提高响应的速度。

* 直接存储器访问控制 \(DMA\)

面对非常复杂的外设，就需要 DMA \(Direct Memory Access\)，数据传送过程不需要 CPU 干预（不需要执行程序指令），是由专门的硬件控制电路控制，进行外设与存储器间直接数据传送，这个专门硬件控制电路被称为 DMA 控制器，简称 DMAC \(Direct Memory Access Controller\)

DMAC 的基本工作步骤：

1. M \(Master\) 部件: 表示这个部件可以在系统总线上主动发起传输， 比如 CPU 就是这样的部件，它可以在系统总线上主动发起读写的传输。
2. S \(Slave\) 部件: 表示这个部件只能被动地接受来自系统总线的传输; 那存储器就是一个典型的只有 slave 接口的设备。 一般的 I/O 接口也是这样，只会接受来自 CPU 的访问， 而 DMA 控制器则是既有 master接口又有 slave 接口。 

![](../../.gitbook/assets/image%20%28107%29.png)

现在的计算机中有很多复杂的外设比如像显示器，网络，硬盘， 这些外设需要传输的数据量很大，而且对传输的速率也有很高的要求， 如果这些数据都要靠CPU一个一个来搬运的话，那恐怕就 难以应对了，所以这就需要用到DMA这种IO控制方式。 DMA就是直接存储器访问的简称。 那如果采用DMA方式进行I/O数据的传送在传送的过程中是 不需要CPU干预的，这个数据传送的工作是由一个专门的硬件电路控制， 可以直接将外设的数据传到存储器或者将存储器中的数据传到外设， 而这个专门的硬件控制电路就称为DMA控制器，简称为DMAC， 其实DMA控制器本身也是一个I/O口， 和其他I/O接口类似，它早期也是采用独立芯片的形式， 而现在通常是寄存在其他多功能的芯片当中。 那我们来看DMA控制器的基本工作步骤。 这是一个简化的系统，里面有一个CPU，一个存储器， 一个I/O接口，还有一个DMA控制器，它们通过系统总线连接在一起， 这里还增加了m和s这两种标记，m是master的缩写 , 而s是slave的缩写，它表示这个部件只能被动地接受来自系统总线的传输。 那存储器就是一个典型的只有slave接口的设备。 一般的I/O接口也是这样，只会接受来自CPU的访问， 而DMA控制器则是既有master接口又有slave接口。 那我们就要用这个DMA控制器进行一次外设到内存的传送， 我们可以把这个I/O接口看成是网卡，外面接着网线， 现在我们需要用DMA的方式接收一个网络包，并保存到存储器的某个区域， 那要完成这个操作，CPU首先需要设置DMA内部的配置寄存器， 那对于x86CPU，我们就要用out指令续写DMA 控制器当中的一些I/O端口，以配置好它的工作模式， 然后这个DMA控制器就处于空闲等待状态，而CPU也可以去执行其他的程序了。 那当外设送来数据到I/O接口的时候， I/O接口就会像DMA控制器发出DMA传送的申请， 这个申请需要通过一根额外的连线发出， 那DMA控制器收到I/O接口的申请之后，还会通过另一个连线响应这个申请， 然后DMA控制器就会通过它的master接口发起总线读传输， 而这个读传输的地址就是这个I/O接口当中的数据输入缓冲寄存器。 那这样数据就会从I/O接口被读到了DMA控置器当中，然后DMA控制器 会向存储器发起总线的写传输，将刚才读回的这个数据写到存储器的某个区域。 我们注意在有DMA控制器之前， 这个系统当中只有CPU可以发起总线传输， 而现在DMA控制器可以主动发起总线传输了。 那接下来DMA控制器会重复五和六这两个动作， 不断地从I/O接口中读出数据再写到存储器当中去， 那如果这时网络传输一直到收完一个网络包， 就次DMA传送才算完成，然后DMA控制器会返回到 第二步，等待I/O发起下一次DMA传送的申请。 那一次DMA传送的数据可能很多， 所花的时间也很长，但是在这段时间CPU一直可以在执行其他的程序， 这样就和数据传送的工作并行起来可以获得很好的系统性能。 但是CPU怎么知道DMA传送已经完成了呢， 那通常情况下DMA传送完成后，DMA控制器会 发出一个中断请求信号，通过中断控制器通知CPU， 那这个DMA控制器发出的中断，也是一个外部中断， 后面的处理过程就和其他I/O接口发出的中断是一样的， 只不过它对应的中断服务程序是让CPU来对这一次的DMA传输进行处理。 所以从这个步骤我们可以看出 DMA方式也不是完全不用CPU来干预，在DMA启动的时候CPU来进行配置 而传送完成后CPU还需要来进行处理。

CPU 需要设置 DMAC 内部配置寄存器，包括：

1. 源地址的初始值及传送时的地址增减方式
2. 目的地址的初始值及传送时的地址增减方式
3. 待传送数据的长度

一般都是 CPU 去写 DMAC 的内部控制器端口对应的地址来设置好状态数据，接下来就交给 DMAC 去处理传输数据的事情，等待 DMAC 完成后，发出中断信号给 CPU，CPU 响应继续后续的处理。

随着 IO 种类的增多以及 IO 设备对数据速率传输等的要求，演化出了独立的 DMAC，也就是某些 IO 接口自带独立的 DMAC 只为当前的 IO 接口服务，这个 DMAC 是集成在 IO 接口的芯片中的，比如显卡、网卡、硬盘控制器等

![&#x72EC;&#x7ACB; DMAC](../../.gitbook/assets/image%20%2898%29.png)

现代的计算系统当中， 大部分对数据传输率有比较高要求的设备都会自带 DMA 控制器， 而其他对数据传输率要求比较低的设备则可以共享系统中独立的 DMA 控制器。 另外这个独立的 DMA 控制器一般还会提供从内存到内存传送的服务。 那当我们编程时需要将内存中的一大块数据复制到内存的另一个区域的时候， 虽然不涉及输入输出，但是也可以享受到 DMA 带来了好处。 那当然也不是所有的输入输出设备都需要使用 DMA 的方式。 毕竟增加一个 DMA 控制器需要增加制造的成本， 而且 CPU 来配置 DMA 控制器以及进行后续的处理 还是要靠执行程序来完成的，也都需要花时间。 如果要传输的数据量很小，性能反而会变差了，数据量大是可以带来性能提升的。



现代更先进的 DMA 技术

