---
description: '#内存 #内存子系统'
---

# Everything about Memory

内存的管理是一个非常重要的工作，C/C++ 编程语言需要程序员手动维护内存分配与释放，而 Java 提供了 GC 进行垃圾回收；此外，在并发编程领域也涉及到缓存和内存的相关问题。

1. 内存需要被划分为固定大小的页 \(Page\)，一般是 4KB
2. 虚拟内存和物理内存，为什么要这么做？
3. 虚拟内存到物理内存的映射是怎么实现的？
4. 进程在运行时是怎么使用内存的？
5. 一个程序在最开始的阶段是在磁盘上的，它是如何变成运行中的进程的？

### Linux 中的内存管理

在 Linux 中内存也是被人为的划分为了物理内存和虚拟内存，物理内存是实实在在存在的内存，也就是每台电脑上的内存条，它基本都是 DRAM，Linux 中只有内核态的程序才可以访问物理内存，也就是说物理内存是被 Linux 内核直接管控的，普通的应用程序要想使用内存，都必须使用系统调用向 Linux 内核申请；但是为了多任务多进程的需要，以及物理内存是有限的，不可能把所有任务的数据和指令都装载到物理内存中，这就需要把不被用到的数据从内存中换出到磁盘上，然后加载新的数据进去，在这其中涉及到一个非常重要的问题是如何定位某个指令或者数据的内存地址问题，如果多个进程都是直接访问物理地址，就何很容易造成地址冲突，就引入了虚拟地址来解决这些问题，但虚拟地址的引入带来了一个内存映射的问题，为了解决这个问题引入了把内存划分为页然后使用页表映射的方案，但是简单的页表映射会存在页表项过大的问题，比如 4KB 一个页，4 GB 的内存就有 100 万个页表项，也就是说单单页表映射就要占用 4M 的内存空间，但是这只是一个程序的内存映射要占用的空间，如果是 100 个进程呢，那就是 400M，那如果是 64 位的系统呢，会更大，为了解决这个问题，引入了多级页表，

内存地址映射的简单步骤：

1. 把虚拟内存地址，切分成页号和偏移量的组合；
2. 从页表里面，查询出虚拟页号，对应的物理页号；
3. 直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。

### Reference

* [每个程序员都应该了解的内存知识 Part1](https://www.oschina.net/translate/what-every-programmer-should-know-about-memory-part1)
* [每个程序员都应该了解的内存知识 Part2 CPU 高速缓存](https://www.oschina.net/translate/what-every-programmer-should-know-about-cpu-cache-part2)
* [每个程序员都应该了解的内存知识 Part 3 虚拟内存](https://www.oschina.net/translate/what-every-programmer-should-know-about-virtual-memory-part3)
* [What Every programmer should know about memory](https://lwn.net/Articles/250967/)



