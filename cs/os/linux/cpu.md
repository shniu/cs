# CPU

## CPU 上下文切换

在每个任务运行前，CPU 都需要知道任务从哪里加载、从哪里开始运行，也就是需要事先设置好每个进程的 CPU 寄存器和程序计数器\(PC\)。CPU 寄存器里的数据和程序计数器等，就是 CPU 执行任务所依赖的环境，也叫做 CPU 上下文。

CPU 上下文切换就是把前一个任务的 CPU 上下文保存下来，然后加载新任务的 CPU 上下文，最后跳转到 PC 计数器所指的指令位置运行新任务。CPU 上下文是保存在系统内核中的，在重新调度时会再次加载进来。

计算机中常见的任务有：进程、线程、硬件触发信号导致的中断等；上下文切换也有不同的类型：进程上下文切换、线程上下文切换、中断上下文切换。

### 查看上下文切换

过多的上下文切换，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，缩短了进程真正的运行时间，会引起系统性能的大幅下降。

vmstat: 这个命令是系统性能分析的常用工具，主要来分析系统的内存使用情况，CPU 上下文切换和中断次数等，但是这个命令只给出了系统整体的上下文切换情况。

```bash
$ vmstat 5
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 1  0      0 2321016  43668 1004128    0    0    48     7   19   42  1  0 98  2  0
 0  1      0 2320900  43668 1004144    0    0     0     0   64  147  0  0 99  0  0
 0  0      0 2320900  43676 1004144    0    0     0     2   56  120  0  0 99  0  0
```

其中：

1. cs \(context switch\) 表示每秒上下文切换的次数
2. in \(interrupt\) 表示每秒中断的次数
3. r \(Running or Runnable\) 表示就绪队列的长度，也就是正在运行和等待 CPU 运行的进程数
4. b \(Blocked\) 表示处于不可中断睡眠状态的进程数

pidstat: 查看每个进程的详细情况

```text
$ pidstat -w 5
Linux 4.15.0-128-generic (xhn-Satellite-C805) 	2021年01月05日 	_x86_64_	(4 CPU)

23时45分54秒   UID       PID   cswch/s nvcswch/s  Command
23时45分59秒     0         8      5.19      0.00  rcu_sched
23时45分59秒     0        11      0.20      0.00  watchdog/0
23时45分59秒     0        14      0.20      0.00  watchdog/1
```

1. cswch: 表示每秒自愿上下文切换（voluntary context switches）的次数，是指进程无法获取所需资源，导致的上下文切换。比如说， I/O、内存等系统资源不足时，就会发生自愿上下文切换
2. nvcswch: 表示每秒非自愿上下文切换（non voluntary context switches）的次数，是指进程由于时间片已到等原因，被系统强制调度，进而发生的上下文切换。比如说，大量进程都在争抢 CPU 时，就容易发生非自愿上下文切换

### 案例

准备

1. Linux 系统，如 Ubuntu
2. 安装 sysbench, sysstat

实验操作前

```text
$ vmstat 1 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 2210752  48652 1100956    0    0    43    10   19   41  1  0 98  1  0
```

使用 sysbench 来模拟多线程调度的瓶颈

```text
# Terminal 1
$ sysbench --test=threads --num-threads=20 --max-time=300 --thread-locks=16 run

```

```text
# Terminal 2
$ vmstat 1
procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st
 0  0      0 2204916  49252 1106520    0    0    33     8   48  450  1  1 97  1  0
 0  0      0 2204924  49252 1106520    0    0     0     0  106  269  1  1 99  0  0
14  0      0 2204140  49252 1106520    0    0     0     0 5909 180470  7  8 85  0  0
16  0      0 2203892  49252 1106552    0    0     0     0 35992 1372876 41 59  1  0  0
13  0      0 2203892  49252 1106552    0    0     0     0 28016 1431627 37 62  1  0  0
10  0      0 2203892  49260 1106552    0    0     0    16 31835 1404845 35 65  0  0  0
13  0      0 2203892  49260 1106552    0    0     0     0 25639 1436761 42 57  1  0  0
17  0      0 2203892  49260 1106552    0    0     0     0 24339 1400306 34 66  1  0  0
 8  0      0 2203892  49260 1106552    0    0     0     0 28976 1410457 39 60  1  0  0
 0  0      0 2204760  49260 1106552    0    0     0     0 17025 1061205 30 44 27  0  0
```

cs 从几百突增到 130 多万，其他指标 r 达到了 16，远远超过了 CPU 核心数 4，存在大量的 CPU 竞争；us 和 sy 的总和也基本升到了 100%，也就是说 CPU 使用率接近饱和，sy 达到了 60%；in 也从几十突增到 3 万，说明中断处理也是潜在问题

综合来看，系统的就绪队列过长，正在运行和等待 CPU 的进程数过多，导致大量的上下文切换，而上下文切换有导致了 CPU 的占用率增高。那么，是什么程序导致的 CPU 升高呢？

```text
# Terminal 3
$ pidstat -w -u 1
00时27分57秒   UID       PID    %usr %system  %guest    %CPU   CPU  Command
00时27分58秒  1000      3581    0.00    1.00    0.00    1.00     0  compiz
00时27分58秒  1000      4514    0.00    1.00    0.00    1.00     3  sshd
00时27分58秒  1000      5250  145.00  239.00    0.00  384.00     2  sysbench

00时27分57秒   UID       PID   cswch/s nvcswch/s  Command
00时27分58秒     0         7      1.00      0.00  ksoftirqd/0
00时27分58秒     0         8     20.00      0.00  rcu_sched
00时27分58秒     0        16      1.00      0.00  ksoftirqd/1
00时27分58秒     0        22      1.00      0.00  ksoftirqd/2
00时27分58秒     0        28      2.00      0.00  ksoftirqd/3
00时27分58秒     0       106      3.00      0.00  kworker/0:2
00时27分58秒     0       300     23.00      0.00  kworker/3:2
00时27分58秒     0      1546      5.00      0.00  Xorg
00时27分58秒     0      3204      1.00      0.00  kworker/1:2
00时27分58秒  1000      3416      1.00      0.00  gpg-agent
00时27分58秒  1000      3581      4.00      6.00  compiz
00时27分58秒  1000      4514    175.00      1.00  sshd
00时27分58秒     0      5221    192.00      0.00  kworker/u16:1
00时27分58秒  1000      5271      1.00    395.00  pidstat
```

可以看到 sysbench 的 CPU 使用率是 384% \(因为是 4 核\)，可见就是 sysbench 导致的 CPU 占用率变高；但是 cswch 和 nvcswch 最高的两个进程是 sshd 和 kworker, 加起来才几百，但是 cs 是 130 多万，问题在哪？

```text
# 加上 -t 参数来查看线程的上下文切换情况
$ pidstat -wt 1
00时33分26秒   UID      TGID       TID   cswch/s nvcswch/s  Command
00时33分27秒     0         7         -      5.13      0.00  ksoftirqd/0
00时33分27秒     0         -         7      5.13      0.00  |__ksoftirqd/0
00时33分27秒  1000         -      5292  11425.64  57748.72  |__sysbench
00时33分27秒  1000         -      5293   9463.25  67377.78  |__sysbench
00时33分27秒  1000         -      5294  15062.39  51217.95  |__sysbench
00时33分27秒  1000         -      5295  13129.06  57511.11  |__sysbench
00时33分27秒  1000         -      5296  13199.15  52889.74  |__sysbench
00时33分27秒  1000         -      5297  17180.34  41735.04  |__sysbench
00时33分27秒  1000         -      5298  14102.56  57418.80  |__sysbench
00时33分27秒  1000         -      5299  15570.94  59605.98  |__sysbench
00时33分27秒  1000         -      5300  11111.11  57129.06  |__sysbench
00时33分27秒  1000         -      5301  12123.08  47066.67  |__sysbench
00时33分27秒  1000         -      5302  14091.45  52449.57  |__sysbench
00时33分27秒  1000         -      5303  12845.30  50861.54  |__sysbench
00时33分27秒  1000         -      5304  10137.61  54517.09  |__sysbench
00时33分27秒  1000         -      5305   9929.91  59026.50  |__sysbench
00时33分27秒  1000         -      5306   8597.44  64456.41  |__sysbench
00时33分27秒  1000         -      5307  13053.85  56073.50  |__sysbench
00时33分27秒  1000         -      5308  11323.93  52934.19  |__sysbench
00时33分27秒  1000         -      5309  12796.58  47368.38  |__sysbench
00时33分27秒  1000         -      5310  12188.03  45700.85  |__sysbench
00时33分27秒  1000         -      5311  13060.68  51256.41  |__sysbench
```

可见，sysbench 线程是 cs 过高的罪魁祸首；但是在 vmstat 的结果中还有一个 in \(中断次数\) 是 3 万多，是怎么回事呢？可以通过查看 /proc/interrupts 这个只读文件，提供了一个只读的中断情况：

```text
$ watch -d cat /proc/interrupts
...
RES:     489962     519490     509604     507306   Rescheduling interrupts
...
```

RES 这个中断类型表示，唤醒空闲状态的 CPU 来调度新的任务运行。这是多处理器系统（SMP）中，调度器用来分散任务到不同 CPU 的机制，通常也被称为处理器间中断（Inter-Processor Interrupts，IPI）。

#### 那么，每秒上下文切换多少次才算正常呢？

这个数值取决于系统本身的 CPU 性能。如果系统的上下文切换次数比较稳定，那么从数百到一万以内，都应该算是正常的。但当上下文切换次数超过一万次，或者切换次数出现数量级的增长时，就很可能已经出现了性能问题。这时，还需要根据上下文切换的类型，再做具体分析。比方说：

1. 自愿上下文切换变多了，说明进程都在等待资源，有可能发生了 I/O 等其他问题；
2. 非自愿上下文切换变多了，说明进程都在被强制调度，也就是都在争抢 CPU，说明 CPU 的确成了瓶颈；
3. 中断次数变多了，说明 CPU 被中断处理程序占用，还需要通过查看 /proc/interrupts 文件来分析具体的中断类型。



