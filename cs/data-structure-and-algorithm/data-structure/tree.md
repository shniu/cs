# Tree

树是一种非线性的数据结构，应用场景很广泛。树的核心概念：

1. 树有根节点、叶子节点、非叶子节点；有同一个父节点的所有节点是兄弟节点
2. 节点的高度（Height）：节点到叶子节点的最长路径
3. 节点的深度（Deep）：根节点到这个节点的最长边数
4. 节点的层（Level）：节点的深度+1
5. 树的高度：根节点的高度

  
二叉树是一种特殊的树，每个节点最多只有左右两个孩子节点。二叉树有满二叉树、完全二叉树。

二叉树的存储方式有：基于指针或引用的二叉链式存储法，基于数组的顺序存储法。链式存储法是大部分树的实现方式。但是如果是完全二叉树，更适合使用数组存储法。堆是一种完全二叉树，适合使用数组来存储。完全二叉树的左子节点和右子节点分别是：2\*i 和 2\*i + 1

重要的树结构

1. 二叉树
2. 满二叉树
3. 完全二叉树
4. 二叉查找树
5. 平衡二叉查找树
6. 红黑树 （这个比较难，先大致了解时间空间复杂度，插入删除查找的效率，由来，适用场景，解决的问题即可）
7. 堆
8. B-Tree 和 B+Tree
9. Trie 树
10. 递归树

树的主要操作：

* 遍历：中序遍历（时间复杂度O\(n\)），前序遍历（时间复杂度O\(n\)），后序遍历（时间复杂度O\(n\)），层次遍历
* 查找节点（时间复杂度跟树高有关系，最坏是O\(n\)，最好是O\(logn\)，平均是O\(logn\)）
* 插入节点（时间复杂度跟树高有关系，最坏是O\(n\)，最好是O\(logn\)，平均是O\(logn\)）
* 删除节点（时间复杂度跟树高有关系，最坏是O\(n\)，最好是O\(logn\)，平均是O\(logn\)）
* 二叉查找树中序遍历输出有序数组
* 二叉查找树找最小节点和最大节点
* 二叉查找树找某个节点的前驱节点和后继节点
* 每个操作的空间复杂度和时间复杂度

二叉搜索树（二叉查找树）是一颗特别的树，它左子树中的各个节点的值都小于当前节点，它右子树的各个节点的值都大于当前节点；二叉搜索树的中序遍历输出有序的数组。重点的操作是查找、插入、删除、遍历等。 如果在构建一个二叉搜索树时，有重复数据，解决办法有两个：相同的数据存储在一个节点中，当前节点支持动态扩容即可；另外一种方式是把相同的值放在右子树中存储，但是在查找、插入、删除的时候，找到这个值后并不停止，而是在右子树中一直找到叶子节点停止。 由于二叉查找树的时间复杂度和树高有关系，所以维护一个相对平衡的二叉树，会让时间复杂度稳定在 O\(logn\), 所以尽量构造一个平衡二叉查找树。

问题

* 散列表已经非常高效了，那它可以替换掉二叉搜索树吗？

1. 从有序性的角度，散列表是无序存储的，二叉查找树是有序的，二叉查找树可以在较低的时间复杂度下输出有序序列
2. 从时间复杂度稳定性的角度，散列表需要计算位置，存在冲突，还需要扩容，所以时间复杂度有时不稳定，二叉查找树的稳定在O\(logn\)
3. 从查找效率的角度，虽然散列表是常量级的，但是有hash函数的耗时和哈希冲突，所以效率并不一定比二叉查找树高
4. 从实现的难易程度的角度，散列表需要考虑散列函数的设计、冲突解决方法、扩容、缩容等，考虑的事情很多，二叉查找树只需要考虑平衡性，所以落地难度会更小一些
5. 从存储空间的角度，散列表的装载因子不能太大，不然会浪费一定的存储空间

所以，各有各的优势，各有各的应用场景

### AVL

什么是 AVL 树，解决了什么问题？AVL 树的每个节点的左右子树的高度相差不超过1，是一颗高度平衡的二叉查找树。

主要是由于二叉查找树在极端情况下会退化成链表，时间复杂度是O\(n\)，效率会降低，所以平衡二叉查找树就是解决了这个问题。平衡二叉查找树：二叉树中任意一个左右子树的高度相差不大于1。 发明平衡二叉查找树的目的是解决二叉查找树在频繁插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题AVL 树 wiki：[https://zh.wikipedia.org/wiki/AVL%E6%A0%91](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)

![](../../../.gitbook/assets/image%20%2885%29.png)

AVL 树能够解决二叉查找树在某些情况下性能退化的问题，主要是通过维护每个节点的平衡因子来做到，使用的方式是4种基本的旋转操作：左旋，右旋，左右旋，右左旋。

但是 AVL 也存在一些缺点，在插入或者删除节点时，很容易引起节点的不平衡，所以会频繁的做旋转操作，在一定程度上会降低操作性能；此外，AVL 需要存储额外信息，比如每个节点的平衡因子；总之，维护成本会比较高。

AVL 是一个严格平衡的二叉查找树，然而有些时候我们并不需要那么严格，所以产生了一些近似平衡二叉树，如红黑树等

### 红黑树

红黑树能确保任何一个节点的左右子树高度差小于两倍

1. 节点一类是黑色的，一类是红色的
2. 根节点是黑色的
3. 每个叶子节点都是黑色的空节点，也就是叶子节点不存储数据
4. 任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的
5. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

红黑树是一个近似平衡的二叉树，根据红黑树的定义分析可知，红黑树的最大高度不会超过 2logn当向红黑树插入节点时可能会破坏红黑树的定义，这个时候就需要调整红黑树以达到平衡特性，主要操作是：左右旋转和颜色改变当在红黑树中删除一个节点同样会破坏红黑树的定义，递归调整以达到平衡Todo： [https://time.geekbang.org/column/article/68976](https://time.geekbang.org/column/article/68976) 红黑树的插入删除深度分析  
红黑树和 AVL 的比较：

1. AVL 比红黑树有更高的查询速度，因为AVL是更严格的平衡
2. 红黑树提供了更加高效的插入和删除操作，因为红黑树的平均旋转操作会更少
3. 红黑树对额外空间的消耗更少，只需要1个bit来存储是黑节点还是红节点，AVL需要一个int类型的数字
4. 红黑树是大部分编程语言实现的基础数据结构，而AVL更多的在数据库中使用；因为红黑树在插入删除多的场景中比较适合，而AVL适合大量读的场景

红黑树的应用场景非常广泛，比如 Linux 的 CPU 任务调度；epoll 的 fd 的维护；nginx 中的 timer 定时器；Java 中 HashMap 的实现

红黑树是一种性能非常稳定的二叉查找树，所以适用的场景是需要动态更新、删除、查找的情况，但红黑树的实现还是相对复杂，所以有时候会使用跳表替代。



## 字典树

又叫 `Trie`，是一种树形结构。同时它还是一种专门用来处理字符串匹配的数据结构，在一组字符串集合中快速查找某个字符串。比较典型的应用是搜索引擎的搜索关键词提示。通过观察 Trie，我们能理解它的本质是利用字符串之间的公共前缀，将重复的前缀合并在一起。

学习 Trie，重点需要掌握以下几点：

* 如何存储 Trie？

Trie 的实现是将字符串进行分割，分成可识别的字符，将这些字符构造成一个树形结构，所以我们需要首先限定字符范围，我们暂时只考虑26个英文字母，如果考虑中文字符等，范围就更加广了。

```java
// 典型的 Trie 树的节点的框架
class TrieNode {
    char data;
    TrieNode[] links = new TrieNode[26];
}
```

说明 Trie 的每个节点都包含 26 个 TrieNode.

* Trie 的常见操作

Trie 需要做的主要操作有两个：根据关键词库构建一个 Trie和从给定的 Trie 中查找一个字符串

```java
public void insert(char[] text);
// or
public void insert(String word);

public boolean search(String word);
// or
public boolean startsWith(String word);
```

我们需要根据关键词的词库动态构建一颗 Trie 树，构建的时间复杂度是 O\(n\), n 是所有关键词的长度和。 对于查找操作，时间复杂度是 O\(k\), k 是要查找单词的长度。

在构建 Trie 时，我们使用了一个数组来表示一个节点，这样会有点浪费内存，但是查询效率会很高，一种空间换时间的思路。但是我们可以对 Trie 的节点做优化，比如使用有序数组、跳表、散列表、红黑树等，以提高内存使用。

* Trie 的特点与限制
* 字符串包含的字符集不能太大，否则内存占用会迅速膨胀。
* 要求字符串的前缀重合比较多，不然空间消耗会变大很多。
* 要实现一个 Trie，需要满足工程化的要求，不是一件容易的事情。
* Trie 是用指针的方式将数据串联起来的，对缓存不友好（因为数据存取是按页的）

Trie 树不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决。Trie 树比较适合的是查找前缀匹配的字符串，比如关键词提示。

## 并查集

Disjoint Set，将 n 个不同的元素分成一组不相交的集合，同时需要两种特别的操作：寻找包含指定元素的唯一集合和合并两个集合。并查集就是这样一种数据结构，基本操作如下：

1. makeSet\(s\): 建立一个新的并查集，其中包含s个单元素集合
2. unionSet\(s1,s2\): 把元素x和元素y所在的集合合并，要求x和y所在的集合不合并，如果相交则不合并
3. find\(x\): 找到x所在集合的代表，该操作也用来判断两个元素是否位于同一集合，只要比较他们各自的代表

非常典型的题目是：朋友圈个数、岛屿数量以及被围绕的区域等。

## 高级搜索

高级搜索由初级搜索演化而来，最容易想到的是暴力搜索，也是最简单的，所谓暴力就是穷举所有可能；在此基础之上，在特定的子问题上做优化，比如对重复子问题记忆化、对不满足的情况提前剪枝；此外，在不同方向上的搜索策略，又可以抽象为深度优先和广度优先，这两种算法都可以做到将所有节点都搜索完毕。以上这些都可以总结为基本的搜索算法，是比较不智能的；那么更加聪明的搜索是在子问题的选择上做优化，更加符合解的趋势。

对于图和图相关的算法会再做个更加深入的总结，以及实现一些比较常用的功能。

