# Tree

树是一种非线性的数据结构，应用场景很广泛。树的核心概念：

1. 树有根节点、叶子节点、非叶子节点；有同一个父节点的所有节点是兄弟节点
2. 节点的高度（Height）：节点到叶子节点的最长路径
3. 节点的深度（Deep）：根节点到这个节点的最长边数
4. 节点的层（Level）：节点的深度+1
5. 树的高度：根节点的高度

  
二叉树是一种特殊的树，每个节点最多只有左右两个孩子节点。二叉树有满二叉树、完全二叉树。

二叉树的存储方式有：基于指针或引用的二叉链式存储法，基于数组的顺序存储法。链式存储法是大部分树的实现方式。但是如果是完全二叉树，更适合使用数组存储法。堆是一种完全二叉树，适合使用数组来存储。完全二叉树的左子节点和右子节点分别是：2\*i 和 2\*i + 1

重要的树结构

1. 二叉树
2. 满二叉树
3. 完全二叉树
4. 二叉查找树
5. 平衡二叉查找树
6. 红黑树 （这个比较难，先大致了解时间空间复杂度，插入删除查找的效率，由来，适用场景，解决的问题即可）
7. 堆
8. B-Tree 和 B+Tree
9. Trie 树
10. 递归树

树的主要操作：

* 遍历：中序遍历（时间复杂度O\(n\)），前序遍历（时间复杂度O\(n\)），后序遍历（时间复杂度O\(n\)），层次遍历
* 查找节点（时间复杂度跟树高有关系，最坏是O\(n\)，最好是O\(logn\)，平均是O\(logn\)）
* 插入节点（时间复杂度跟树高有关系，最坏是O\(n\)，最好是O\(logn\)，平均是O\(logn\)）
* 删除节点（时间复杂度跟树高有关系，最坏是O\(n\)，最好是O\(logn\)，平均是O\(logn\)）
* 二叉查找树中序遍历输出有序数组
* 二叉查找树找最小节点和最大节点
* 二叉查找树找某个节点的前驱节点和后继节点
* 每个操作的空间复杂度和时间复杂度

二叉搜索树（二叉查找树）是一颗特别的树，它左子树中的各个节点的值都小于当前节点，它右子树的各个节点的值都大于当前节点；二叉搜索树的中序遍历输出有序的数组。重点的操作是查找、插入、删除、遍历等。 如果在构建一个二叉搜索树时，有重复数据，解决办法有两个：相同的数据存储在一个节点中，当前节点支持动态扩容即可；另外一种方式是把相同的值放在右子树中存储，但是在查找、插入、删除的时候，找到这个值后并不停止，而是在右子树中一直找到叶子节点停止。 由于二叉查找树的时间复杂度和树高有关系，所以维护一个相对平衡的二叉树，会让时间复杂度稳定在 O\(logn\), 所以尽量构造一个平衡二叉查找树。

问题

* 散列表已经非常高效了，那它可以替换掉二叉搜索树吗？

1. 从有序性的角度，散列表是无序存储的，二叉查找树是有序的，二叉查找树可以在较低的时间复杂度下输出有序序列
2. 从时间复杂度稳定性的角度，散列表需要计算位置，存在冲突，还需要扩容，所以时间复杂度有时不稳定，二叉查找树的稳定在O\(logn\)
3. 从查找效率的角度，虽然散列表是常量级的，但是有hash函数的耗时和哈希冲突，所以效率并不一定比二叉查找树高
4. 从实现的难易程度的角度，散列表需要考虑散列函数的设计、冲突解决方法、扩容、缩容等，考虑的事情很多，二叉查找树只需要考虑平衡性，所以落地难度会更小一些
5. 从存储空间的角度，散列表的装载因子不能太大，不然会浪费一定的存储空间

所以，各有各的优势，各有各的应用场景

### AVL

什么是 AVL 树，解决了什么问题？AVL 树的每个节点的左右子树的高度相差不超过1，是一颗高度平衡的二叉查找树。

主要是由于二叉查找树在极端情况下会退化成链表，时间复杂度是O\(n\)，效率会降低，所以平衡二叉查找树就是解决了这个问题。平衡二叉查找树：二叉树中任意一个左右子树的高度相差不大于1。 发明平衡二叉查找树的目的是解决二叉查找树在频繁插入、删除等动态更新的情况下，出现时间复杂度退化的问题。

发明平衡二叉查找树这类数据结构的初衷是，解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题AVL 树 wiki：[https://zh.wikipedia.org/wiki/AVL%E6%A0%91](https://zh.wikipedia.org/wiki/AVL%E6%A0%91)

![](../../../.gitbook/assets/image%20%2885%29.png)

AVL 树能够解决二叉查找树在某些情况下性能退化的问题，主要是通过维护每个节点的平衡因子来做到，使用的方式是4种基本的旋转操作：左旋，右旋，左右旋，右左旋。

但是 AVL 也存在一些缺点，在插入或者删除节点时，很容易引起节点的不平衡，所以会频繁的做旋转操作，在一定程度上会降低操作性能；此外，AVL 需要存储额外信息，比如每个节点的平衡因子；总之，维护成本会比较高。

AVL 是一个严格平衡的二叉查找树，然而有些时候我们并不需要那么严格，所以产生了一些近似平衡二叉树，如红黑树等

### 红黑树

红黑树能确保任何一个节点的左右子树高度差小于两倍

1. 节点一类是黑色的，一类是红色的
2. 根节点是黑色的
3. 每个叶子节点都是黑色的空节点，也就是叶子节点不存储数据
4. 任何相邻的节点都不能同时为红色，红色节点是被黑色节点隔开的
5. 每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点

红黑树是一个近似平衡的二叉树，根据红黑树的定义分析可知，红黑树的最大高度不会超过 2logn当向红黑树插入节点时可能会破坏红黑树的定义，这个时候就需要调整红黑树以达到平衡特性，主要操作是：左右旋转和颜色改变当在红黑树中删除一个节点同样会破坏红黑树的定义，递归调整以达到平衡Todo： [https://time.geekbang.org/column/article/68976](https://time.geekbang.org/column/article/68976) 红黑树的插入删除深度分析  
红黑树和 AVL 的比较：

1. AVL 比红黑树有更高的查询速度，因为AVL是更严格的平衡
2. 红黑树提供了更加高效的插入和删除操作，因为红黑树的平均旋转操作会更少
3. 红黑树对额外空间的消耗更少，只需要1个bit来存储是黑节点还是红节点，AVL需要一个int类型的数字
4. 红黑树是大部分编程语言实现的基础数据结构，而AVL更多的在数据库中使用；因为红黑树在插入删除多的场景中比较适合，而AVL适合大量读的场景

红黑树的应用场景非常广泛，比如 Linux 的 CPU 任务调度；epoll 的 fd 的维护；nginx 中的 timer 定时器；Java 中 HashMap 的实现

红黑树是一种性能非常稳定的二叉查找树，所以适用的场景是需要动态更新、删除、查找的情况，但红黑树的实现还是相对复杂，所以有时候会使用跳表替代。

