# 题目列表

## Todo List

* [ ] [滑动窗口类问题解题思路](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/hua-dong-chuang-kou-ji-qiao)
* [ ] 刷题方法，刷题后写总结，多遍刷题，总结套路和思路，代码实现的常用模式
* [ ] 对算法与数据结构做知识分类和思维导图
* [ ] 阅读[如何刷 《剑指 offer 》](https://www.toutiao.com/i6795063003059323404/)
* [ ] 阅读 程序员面试金典 Cracking the code interview
* [ ] [https://shimo.im/docs/KKvkRRhddqJXvxd8](https://shimo.im/docs/KKvkRRhddqJXvxd8) 爬楼梯变种 [爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/), [爬楼梯问题变种](https://shimo.im/docs/KKvkRRhddqJXvxd8) （动态规划的入门题目，记忆化递归）
* [ ] 如何实现LRU算法？[实现代码在 Github 上](https://github.com/shniu/java-eco/blob/master/notes/arts/src/main/java/io/github/shniu/arts/algothrim/leetcode/lruCache/LRUCache.java)，[分析在这里](https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/lru-suan-fa)
* [ ] [二叉树常见操作](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-sou-suo-shu-cao-zuo-ji-jin)
* [ ] 内部排序算法和外部排序算法，[参考1](http://c.biancheng.net/data_structure/sort/)
* [ ] [二叉搜索树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-zui-jin-gong-gong-zu-xian-lcof/) \(2.29\)
* [ ] [二叉树的最近公共祖先](https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof/) 多解法 \(2.29\)
* [ ] [合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/) （2.29）想想用递归怎么实现
* [ ] [两数相加](https://leetcode-cn.com/problems/add-two-numbers/) \(2.29\)
* [ ] [删除链表的倒数第N个节点](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/) （2.29）
* [ ] [合并k个排序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/) （2.29） 有些难度 利用小顶堆实现了，想一下啊用递归怎么实现
* [ ] [两两交换链表里的节点](https://leetcode-cn.com/problems/swap-nodes-in-pairs/) （2.29）想递归怎么实现
* [ ] [旋转链表](https://leetcode-cn.com/problems/rotate-list/) （2.29）
* [ ] [返回倒数第k个节点](https://leetcode-cn.com/problems/kth-node-from-end-of-list-lcci/) （3.1）想递归怎么实现
* [ ] [链表中倒数第k个节点](https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof/)（3.1） 和上面这个题是一样的
* [ ] [用两个栈实现队列](https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/) （3.1）
* [ ] [用队列实现栈](https://leetcode-cn.com/problems/implement-stack-using-queues/) （3.1）
* [ ] [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) （3.1） 想递归写法
* [ ] [删除排序链表中的重复元素](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list/) （3.1）curr 和 curr.next
* [ ] [删除排序链表中的重复元素II](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii/) （3.1）
* [ ] [反转链表](https://leetcode-cn.com/problems/reverse-linked-list/) （3.1） 迭代+递归两种方法实现
* [ ] [反转链表II](https://leetcode-cn.com/problems/reverse-linked-list-ii/) （3.1） 相比上面增加了反转位置的查找
* [ ] [如何去除有序数组中的重复元素](https://labuladong.gitbook.io/algo/gao-pin-mian-shi-xi-lie/ru-he-qu-chu-you-xu-shu-zu-de-zhong-fu-yuan-su) （3.1）
* [ ] [二叉树中和为某一值的路径](https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof/) （3.1） 引申一下如何求root到指定节点的路径
* [ ] 二叉搜索树与双向链表
* [ ] 复杂链表的复制
* [ ] 数值的整数次方
* [ ] 青蛙跳台阶问题
* [ ] 机器人的运动范围
* [ ] [对称二叉树](https://leetcode-cn.com/problems/symmetric-tree/) 或者 [镜像二叉树](https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof/) （3.1）
* [ ] [数组中重复的数字](https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof/) （3.2） 有种思路不好想到，你知道是什么吗？
* [ ] [二维数组中的查找](https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/) （3.2） 有两种比较好的思路：二分和搜索范围缩小
* [ ] [动态规划基础详解](https://labuladong.gitbook.io/algo/di-ling-zhang-bi-du-xi-lie/dong-tai-gui-hua-xiang-jie-jin-jie#yi-fei-bo-na-qi-shu-lie) （3.2） 可以多度几遍，包含了斐波那契数列和凑硬币
* [ ] [无重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters) （3.17）
* [ ] 如何使用栈实现队列？[参考这里](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dui-lie-shi-xian-zhan-zhan-shi-xian-dui-lie)

  基本思路：使用两个栈，s1和s2，元素压入s1，取的时候从s2取，如果s2为空，就把s1的元素出栈压入s2，再从s2取数据

* [ ] 如何使用队列实现栈？[参考这里](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/dui-lie-shi-xian-zhan-zhan-shi-xian-dui-lie)

  基本思路：使用一个队列就能搞定，记录队尾元素（也就是栈顶元素），push的时候直接入队列更新队尾元素即可；出栈时，将队首元素依次插入队列尾部，将尾部元素弹出即可，有个循环，复杂度O\(n\); 也可以考虑使用两个队列（始终保持一个队列是空的）

* [ ] [二叉树操作](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/er-cha-sou-suo-shu-cao-zuo-ji-jin)

**必知必会**

* 手写二叉树的前中后遍历（分别使用递归和非递归方式实现）
* 手写二叉树的层次遍历（使用非递归和递归方式）
* 手写冒泡排序、插入排序、选择排序、归并排序、快速排序，了解堆排序的原理（二叉堆）
* 手写栈和队列的实现，用栈实现队列和队列实现栈
* 实现广度优先搜索和深度优先搜索（基于图）
* 将两个有序数组合并为一个有序数组（done）
* 散列表的核心设计和原理，常见的问题如何解决，并能分析Java的HashMap的实现
* 实现[反转链表](https://leetcode-cn.com/problems/reverse-linked-list) 和 [反转链表II](https://leetcode-cn.com/problems/reverse-linked-list-ii/)，参考[官方题解](https://leetcode-cn.com/problems/reverse-linked-list-ii/solution/fan-zhuan-lian-biao-ii-by-leetcode/)

## 基础知识点

### 栈，队列，优先队列，双端队列

* 栈的基本实现：用数组实现栈/用链表实现栈/数组实现的栈支持动态扩容
* 在 Golang 中栈并没有标准实现，可以手动实现一个栈用作底层库
* 编程实现一个浏览器的前进和后退功能
* 栈的应用：函数调用，浏览器前进后退，表达式求值，括号匹配
* 队列的基本实现：用数组/用链表分别实现顺序队列和链式队列
* 实现一个循环队列，其实就是 RingBuffer
* 优先队列实现原理，以及在Java和Golang中的实现
* 双端队列的实现原理
* 用栈实现队列，用队列实现栈

## LeetCode

* [155.最小栈](https://leetcode-cn.com/problems/min-stack/)
* [641.设计循环双端队列](https://leetcode-cn.com/problems/design-circular-deque)
* [20.有效的括号](https://leetcode-cn.com/problems/valid-parentheses/)
* [84.柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram)
* [239.滑动窗口最大值](https://leetcode-cn.com/problems/sliding-window-maximum/)
* [50.Pow\(x,n\)](https://leetcode-cn.com/problems/powx-n/)
* [78.子集](https://leetcode-cn.com/problems/subsets/)
* [169.求众数](https://leetcode-cn.com/problems/majority-element)  有很多种解法
* [17.电话号码的字母组合](https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number/)
* [51.N皇后](https://leetcode-cn.com/problems/n-queens/)
* [200.岛屿数量](https://leetcode-cn.com/problems/number-of-islands)
* [36.有效的数独](https://leetcode-cn.com/problems/valid-sudoku/)
* [102.二叉树的层次遍历](https://leetcode-cn.com/problems/binary-tree-level-order-traversal) [英文站](https://leetcode.com/problems/binary-tree-level-order-traversal)

要点：二叉树的层次遍历，思想接近图的BFS。实现方式1，使用queue做辅助进行遍历；实现方式2，使用递归，将层次信息和结果信息做追踪

* [433.最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/) [英文站](https://leetcode.com/problems/minimum-genetic-mutation/)

要点：和单词接龙的题目相似，在基因库中使用BFS算法进行搜索，记录访问的字符串和使用队列进行BFS；优化的方向是使用双向的BFS，这样会更快一些。

* [127.单词接龙](https://leetcode-cn.com/problems/word-ladder/) [英文站](https://leetcode.com/problems/word-ladder/)

要点：对问题做转化，转变成基于图的BFS或者基于图的双向BFS

* [126.单词接龙II](https://leetcode-cn.com/problems/word-ladder-ii/) [英文站](https://leetcode.com/problems/word-ladder-ii/)
* [22.括号生成](https://leetcode-cn.com/problems/generate-parentheses) [英文站](https://leetcode.com/problems/generate-parentheses)
* ~~~~[~~515.在每个树行中找最大值~~](https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row)~~~~
* 零钱兑换 \(322\)

  给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。

滑动窗口问题 接雨水问题 数字组合问题 单词接龙 平方根

## 算法相关面试题

* 求一棵树中，从点1开始遍历完树中所有点的最短距离，所有相邻点之间的距离是1 \(美团面试题\)

理解题意： 思路： 实现：

* 二分图判定
* 最短路径算法，BFS Dijkstra 等，输出最短路径

